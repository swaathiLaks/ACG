'''
Server Program

StudentID: P2227171
Name: Swaathi Lakshmanan
Class: DISM/FT/1B/05
Assessment: Assignment 2

Script name:
server.py

Purpose: 
Contains all the code for the server to start the server.

Usage Syntax:
Run with command line: python .\server.py

Input/output files:
d:/Assignment 2/keys.db
d:/Assignment 2/menu_today.txt
d:/Assignment 2/temp
Other files generated by program

Input files:
d:/Assignment 2/creceiver.pem
d:/Assignment 2/hangman_hanged.txt

Python version:
Python 3

Reference:
None

Library/Module:
Install pysqlitecipher module: pip install pysqlitecipher==0.11

Known issues:
None
'''
# imports
from threading import Thread
import socket
import datetime
import sys
import traceback
import time
import commonfn
from pysqlitecipher import sqlitewrapper

global host, port
cmd_GET_MENU = "GET_MENU"
cmd_END_DAY = "CLOSING"
default_menu = "menu_today.txt"
default_save_base = "result-"
host = socket.gethostname() 
port = 8888 

# Intial verfication code
try:
    upassword=input("Enter Password for database: ")
    obj = sqlitewrapper.SqliteCipher(dataBasePath="keys.db" , checkSameThread=False , password=upassword)
except:
    print("Password is wrong.")
    exit()
keys = (obj.getDataFromTable("mykeys" , raiseConversionError = True , omitID = False))

# Code to view/ edit data
askuser=input("Would you like to edit or view files (enter (y) if you want to): ").lower()
if askuser=="y":
    commonfn.viewfromdatabase(keys[1])
privkey=keys[1][1][2]

def process_connection( conn , ip_addr, MAX_BUFFER_SIZE):  
    blk_count = 0
    net_bytes = conn.recv(MAX_BUFFER_SIZE)
    dest_file = open("temp","w")  
    while net_bytes != b'':
        if blk_count == 0: 
            usr_cmd = net_bytes[0:15].decode("utf8").rstrip()
            if cmd_GET_MENU in usr_cmd: 
                try:

                    # decrypt menu_today.txt
                    commonfn.storprivkey(keys[1][0][2],'menu_today.txt',False)

                    src_file = open(default_menu,"rb")
                except:
                    print("file not found : " + default_menu)
                    sys.exit(0)
                while True:
                    
                    read_bytes = src_file.read(MAX_BUFFER_SIZE)
                    if read_bytes == b'':
                        break

# ENCRYPTION SCHEME

                    # generating new session key
                    seskey=commonfn.genseskey()

                    # encrypting data with session key
                    ciphTxt,tag,nonce=commonfn.enWithSesKey(seskey,read_bytes)

                    # creating digital signature
                    signature=commonfn.ensignature(read_bytes,privkey) 

                    # encrypting session key
                    enSesKey=commonfn.encrypting(seskey,'creceiver.pem')

                    # concatenating all data
                    read_bytes=(signature+b'\n\n\nSIGN'+ciphTxt+b'\n\n\nSIGN'+tag+b'\n\n\nSIGN'+enSesKey+b'\n\n\nSIGN'+nonce)

# ENCRYPTION SCHEME

                    conn.send(read_bytes)
                src_file.close()

                # encrypt menu_today.txt
                commonfn.storprivkey(keys[1][0][2],'menu_today.txt')
                
                print("Processed SENDING menu") 
                return
            elif cmd_END_DAY in usr_cmd:  
                now = datetime.datetime.now()
                filename = default_save_base +  ip_addr + "-" + now.strftime("%Y-%m-%d_%H%M")   
                dest_file = open(filename,"wb")
                # e.g. plain_bytes = my_decrypt(net_bytes)
                dest_file.write( net_bytes[ len(cmd_END_DAY): ] )
                blk_count = blk_count + 1
        else:  
            dest_file = open(filename,"wb")
            net_bytes = conn.recv(MAX_BUFFER_SIZE)

# INTEGRITY, NON REPUDIATION AND DECRYPTING
            if len(net_bytes)!=0:

                # splitting data
                newList=(net_bytes).split(b'\n\n\nSIGN')

                # decrypting syession key
                reseskey=commonfn.decrypting(newList[3],privkey)

                # decrypting data
                data=commonfn.deWithSesKey(reseskey,newList[1],newList[2],newList[4])

                # verifying signature
                ishash=commonfn.designature(data,'creceiver.pem',newList[0])
                if ishash:
                    print('Integrity and Non-repudiation checked.')
                    val='y'
                else:
                    print('Either integrity or non-repudiation is corrupted. Would you like to continue writing to the file?')
                    val=input("Enter 'y' to continue writing to the the file: ").lower()

# INTEGRITY, NON REPUDIATION AND DECRYPTING 

# ENCRYPTING DATA AT REST

            if val=='y':
                if len(net_bytes)>0:

                    # generating new fernet key
                    newkey=commonfn.ferkey()

                    # adding key to database
                    obj.insertIntoTable("mykeys" , [filename,newkey] , commit = True)

                    # enccrypting plaintext data with new key
                    endata=commonfn.enrest(newkey,data)

# ENCRYPTING DATA AT REST

                    dest_file.write(endata)
    # last block / empty block
    dest_file.close()
    print("saving file as " + filename)
    time.sleep(3)
    print("Processed CLOSING done") 
    return

def client_thread(conn, ip, port, MAX_BUFFER_SIZE = 4096):
    process_connection( conn, ip, MAX_BUFFER_SIZE)
    conn.close()  
    print('Connection ' + ip + ':' + port + "ended")
    return

def start_server():
    global host, port
    soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    soc.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    print('Socket created')
    
    try:
        soc.bind((host, port))
        print('Socket bind complete')
    except socket.error as msg:
        
        print('Bind failed. Error : ' + str(sys.exc_info()))
        print( msg.with_traceback() )
        sys.exit()

    soc.listen(10)
    print('Socket now listening')

    try:
        while True:
            conn, addr = soc.accept()
            # assign ip and port
            ip, port = str(addr[0]), str(addr[1])
            print('Accepting connection from ' + ip + ':' + port)
            try:
                Thread(target=client_thread, args=(conn, ip, port)).start()
            except:
                print("Terrible error!")
                traceback.print_exc()
    except:
        pass
    soc.close()
    return

start_server()  


